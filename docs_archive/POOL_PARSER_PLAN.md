1. config ファイルを読みこみ辞書に入れる。
   ✅ **実装済み**: `load_config_file_to_pool()` 関数で実装。YAML ファイルを読み込んで `OptionPool` に変換。

2. command line options を辞書に入れる。
   ✅ **実装済み**: `parse_command_line_to_dict()` 関数で実装。

   1. そのためには、各オプションの引数の個数を知っていなければならないが、それは手順上難しいので、ベクトルや行列の場合には数値の区切りにコンマを指定する(現在の仕様から改訂)
      ⚠️ **未実装**: 現状は空白区切りで複数値を扱う (`process_option_arg()` で `--option val1 val2` 形式)。コンマ区切りへの改訂は未実装。計画では「現在の仕様から改訂」とあるが、実装では空白区切りのまま。

3. 1 を 2 で上書きして全設定とし、pool に入れる。
   ✅ **実装済み**: `parse_args()` 内で `pool.options[key] = value` で上書き。
   1. 上書きする場合は logger.info を表示。
      ❌ **未実装**: 上書き時に `logger.info` を表示する機能は実装されていない。現状は `logger.debug` のみ（デバッグモード時）。
   2. 列挙型のオプション(--anion, --cation, --guest, --spot\_\*)の場合は上書きではなく書き足す。
      ⚠️ **部分的実装**: コマンドラインで同じオプションが複数回指定された場合はリストに変換される (`process_option_arg()` 240-244 行目)。しかし、config ファイルと CLI 間のマージ時には上書きになっている（488-489 行目）。列挙型オプションの識別と書き足し処理は未実装。!!この部分は現在の実装のほうが良いですね。

ここまでで辞書が完成する。ここまでは 1 つの関数で処理する。
✅ **実装済み**: `parse_args()` メソッド内で処理（460-517 行目）。ただし、`load_config_file_to_pool()` と `parse_command_line_to_dict()` は別関数として分離されている。

以下は階層的かつ機動的に処理する必要がある。各プラグインは自分が処理すべきオプションを知っているので、処理をまかせる。
✅ **実装済み**: `_execute_plugin_chain()` メソッドで動的にプラグインチェーンを実行。

4. base level の parser は自分の処理すべきオプションを知っている。
   ✅ **実装済み**: `_build_options_dict()` 内で実装（729-791 行目）。`BASE_LEVEL_OPTIONS` で定義されたオプションを処理。

   1. pool にある設定のうち、自分に関係のあるものを処理する。
      ✅ **実装済み**: `parse_options_generic()` を使用して処理。

5. exporter の parser も自分の処理すべきオプションを知っている。
   ✅ **実装済み**: `_execute_plugin_chain()` 内で実装（593-610 行目）。

   1. pool にある設定のうち、自分に関係のあるものを処理する。
      ✅ **実装済み**: exporter プラグインの `parse_options` 関数が処理。
   1. []で囲んでオプションを同時に与えられた場合は、それらでさらに上書き/書き足しする。
      ✅ **実装済み**: `parse_bracketed_plugin()` 関数でパースし、pool に追加（800-802 行目、809-811 行目）。
      1. 上書きする場合は logger.info を表示
         ❌ **未実装**: []で囲んだオプションを処理する際の `logger.info` 表示は未実装。
   1. exporter のオプションの中には、引数に molecule 型を含む場合がある。その場合も、
      ✅ **実装済み**: `water_model` オプションに基づいて molecule プラグインを動的にチェーンに追加（612-677 行目）。

6. unitcell の parser も自分の処理すべきオプションを知っている。
   ✅ **実装済み**: `_execute_plugin_chain()` 内で実装（572-591 行目）。unitcell プラグインの `parse_options` 関数が処理。

7. molecule の parser も自分の処理すべきオプションを知っている。
   ✅ **実装済み**: `_execute_plugin_chain()` 内で実装（621-677 行目）。molecule プラグインの `parse_options` 関数が処理。

## 実現上の問題点

1. **コンマ区切りへの改訂**: 計画ではベクトル/行列のコンマ区切りへの改訂を想定しているが、現状は空白区切りのまま。改訂する場合は `parse_option_string()` と `process_option_arg()` の修正が必要。

2. **列挙型オプションの識別**: `--anion`, `--cation`, `--guest`, `--spot_*` など列挙型オプションを識別する仕組みが必要。現状は同じオプションが複数回指定された場合のみリスト化されるが、config と CLI 間のマージでは上書き。

3. **logger.info の実装場所**: 上書き時に `logger.info` を表示する場合、以下の場所で実装が必要：

   - config と CLI のマージ時（488-489 行目付近）
   - []で囲んだオプション処理時（800-802 行目、809-811 行目付近）

4. **exporter オプションの分離**: 現状、unitcell のオプションと exporter のオプションが明確に分離されていない（`_build_options_dict()` で `unprocessed` をそのまま `unitcell_options` に設定）。exporter 専用のオプションを識別する仕組みが必要かもしれない。

5. **順序の問題**: 計画では「ここまでは 1 つの関数で処理する」とあるが、実装では `load_config_file_to_pool()` と `parse_command_line_to_dict()` が別関数。これは設計上の問題ではなく、コード整理のための分離なので問題なし。

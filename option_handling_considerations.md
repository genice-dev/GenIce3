## YAMLの構造の検討

```yaml
unitcell:
  name: A15

  # 単位胞内のカチオン（サイト番号: イオン名）
  cation:
    "0": N

  # 単位胞内カチオンへの group 指定（サイト番号: { ケージID: group名 }）
  cation_groups:
    "0": { 1: methyl, 6: methyl, 3: methyl, 4: methyl }

  anion:
    "2": Cl
```

YAMLでこんな風にオプションを指定している。

僕はこれよりは、きちんと階層になった、次の方法のほうが整然として見える。

```yaml
unitcell:
  name: A15

  # 単位胞内のカチオン（サイト番号: イオン名）
  cation:
    ion: "N"
    site: 0
    # 単位胞内カチオンへの group 指定（サイト番号: { ケージID: group名 }）
    groups: { 1: methyl, 6: methyl, 3: methyl, 4: methyl }

  anion:
    ion: Cl
    site: 2
```

groupが連結するcationの場合は階層がある表記が良いが、単原子anionの場合には逆に冗長になってしまう。

これを、うまくYAMLで表現できないか。階層がうまく整理されれば、オプションの階層的な指定方法もおのずと決まるだろう。

---

### 案: サイトをキーに統一し、値だけ「簡潔／階層」を使い分ける

- **ルール**: `cation` / `anion` の値は次のどちらかだけ許す。
  - **文字列** → そのサイトのイオン名だけ（group なし）
  - **オブジェクト** → `ion` 必須、`groups` は任意

```yaml
unitcell:
  name: A15

  cation:
    "0": # サイト 0: group あり → 階層
      ion: N
      groups: { 1: methyl, 6: methyl, 3: methyl, 4: methyl }
    "1": K # サイト 1: group なし → 1行で十分

  anion:
    "2": Cl # 単原子はこのままで冗長にならない
```

- 単原子 anion は `"2": Cl` のままなので冗長にならない。
- group がつく cation は、そのサイトの値だけオブジェクトにし、`ion` と `groups` で階層がはっきりする。
- キーは常にサイトIDなので、`site` を別キーで書く必要がない（「整然とした」例で冗長だった部分を削れる）。
- 文法は「値が string か { ion, groups? } のどちらか」の1ルールにできる。CLI の階層オプションも同じ考え方（サイト → イオン名だけ or イオン名＋group）に揃えやすい。

## オプションの表記

LISP的に書くなら（括弧と空白だけなので `=` / `:` が不要。階層は明確）:

```text
(unitcell (name A15) (cation (0 (ion N) (groups (1 methyl) (6 methyl) (3 methyl) (4 methyl)))) (anion (2 Cl)))
```

S式としてパースすれば同じ内部構造に落とせる。設定ファイルは YAML、CLI の1行階層は S式、という住み分けもあり。

**YAML flow を採用する案**: S式と情報量は近いが少し読みやすい。同じパーサーで複数行（設定ファイル）も1行（CLI に渡す文字列）も読める。コマンドラインに YAML を直に書くプログラムはあまり見ないが、設定と記法を一つに揃えられる利点が大きい。

**関数的（S式）がよい**: `=` や `:` を増やさず、括弧と並びだけで階層を表せる。利点は「とりあえず」が短いこと。

- 最小: `genice3 1h` のまま（第一引数＝単位胞名）
- オプションを足す: `genice3 1h (exporter gromacs)` や `genice3 A15 (rep 2 2 2) (exporter gromacs)`
- 複雑なときだけ S 式で全体を渡す

第一引数が単位胞を表すので、YAML flow の `genice3 { unitcell: { name: 1h } }` のような冗長さにならない。

**僕の考える関数っぽい表記**: 適用風のネスト `名前(引数...)` で階層を表し、必要なところだけ `key=value` を使う。単位胞名の直後に括弧でオプションを並べる。

```text
genice3 "A15(cation(N(site=0) group(methyl(cage=1) methyl(cage=6))) anion(Cl(site=2))) rep(2,2,2) seed"
```

**かなりフラットな表記**: `--density`はunitcellのサブオプションだが、ユーザーにとってはどうでもいいことなので、baseにそのまま書いても問題ないことにする。一方、--groupは明らかにイオンの属性だが、フラットに書こうとすると毎度イオンを特定する必要がでてくる。妥協案として、groupのように直前のオプションに支配されるオプションでは表記をすこし変えるのはどうだろう。

- サブオプションは`---`

  ```text
  genice3 A15 --cation 0=N ---group 1=methyl 6=methyl --anion 2=Cl --rep 2 2 2 --seed
  ```

  さらにサブサブオプションがある場合は同様に

  ```text
  genice3 A15 --cation 0=N ---group 1=methyl ----UA 6=methyl ----atomic --anion 2=Cl --rep 2 2 2 --seed
  ```

- サブオプションは`@`

  ```text
  genice3 A15 --cation 0=N @group 1=methyl 6=methyl --anion 2=Cl --rep 2 2 2 --seed
  ```

  サブオプションだと自己主張しないぶん、`@group`が`--cation`に従属していることがわかりやすい。ただし、これだと階層をさらに深くしづらい。`methyl`にオプションが欲しいときはどう書く?

  **サブサブオプションの候補**:
  - 並列に`@`を重ねる: `@group 1=methyl@UA 6=methyl@atomic`（同じ`@`レベルは直前の値に効く）
  - 値のうしろに`:subopt`で続ける: `@group 1=methyl:UA,atomic 6=methyl`（分子名にオプションをくっつける）

  **分子か分子以外かで書き分ける**: 結局、サブサブまで必要になるのは分子・残基のオプション（UA/atomic など）のときなので、「sub か subsub か」で記法を分けるより、「分子（残基）のオプション」と「それ以外のサブオプション」で書き方を分けるのも手。分子オプションは `methyl:UA,atomic` のように値に付加、それ以外（例: group が cation に従属するようなもの）は `@group ...` のままにすると、階層の深さを数えずに済む。
  - suboptionほど緊密度の高い表記にするのは自然。逆に、`---`のような階層表現は直感に反し、読みづらい。
  - GenIce2のformatオプション(現在のexporter)には、かなりいろんなオプションがあったので、いろんなオプション表現をさまたげない、かつ読みやすい記法が必要。
  - `--`と`@`は第一階層、第二階層のkeyで、valueには特に記号がなく、すきなだけ並べてもよい。

  ```text
  genice3 A15 --cation 0=N @group 1=methyl 6=methyl \
      --anion 2=Cl \
      --rep 2 2 2 \
      --seed 99 \
      --exporter svg @shadow @rotate x=5 y=2 x=3 @size O=0.3 H=0.1 HB=0.05 \
      --water 4site @ice
  ```

- **サブオプションの接頭辞に使う記号**: シェルが解釈しない記号がよい。候補の挙動をまとめる。
  - `@`: シェルでは無視される。そのまま `@group` と書けてクォート不要。メールや「〜に」のイメージで馴染みもある。
  - `!`: bash では履歴展開のトリガーになる。対話シェルで `!group` と打つと意図しない置換が起きることがあり、避けるか、使うなら単一引用で `'!group'` が必要。スクリプトでは `set +H` にしていれば問題になりにくい。
  - `^`: 通常はシェルで特別扱いされない。クォート不要。修飾子・上付きのニュアンスで「直前のオプションに効く」と解釈しやすい。
  - `%`: 対話シェルではジョブ指定（`%1` など）に使うが、`%group` のようにアルファベットが続く場合は多くのシェルで展開されない。やや文脈依存。
  - `:`: `:shadow` のように接頭辞にすると、シェルではただの引数の一部なので解釈されず安全。打ちやすく、CSS の `:hover` や名前空間の区切りなど「修飾・下位」のイメージとも合う。一方で、分子オプションで値のうしろに `methyl:UA,atomic` とすでに `:` を使う案があるので、「`:` はサブ／修飾」で接頭辞・接尾辞どちらも統一するか、接頭辞は別記号にして役割を分けるか、という選択になる。
  - `#`: コメント開始のため、そのままでは使えない。
  - `$` `*` `?` `&` `|` `;` `` ` `` など: 展開・グロブ・制御に使うため不向き。

  まとめ: クォートなしでどこでも使うなら `@` か `^` か `:` が無難。`:shadow` は書きやすく意味も取りやすいが、値側の `methyl:UA,atomic` と役割を揃えるかどうかで決めるとよさそう。`!` は意味は伝わりやすいが履歴展開に注意。

  ```text
  genice3 A15 --cation 0=N ^group 1=methyl 6=methyl \
      --anion 2=Cl \
      --rep 2 2 2 \
      --seed 99 \
      --exporter svg ^shadow ^rotate x=5 y=2 x=3 ^size O=0.3 H=0.1 HB=0.05 \
      --water 4site ^ice
  ```

  視覚的には、存在感のある`@`のほうが良い気がする。

  サブオプションに`:`、分子オプションに`@`を使った場合。分子の世界では`x@y`は包接を表し、`x<y`なので、オプションの表記としては逆向きっぽいな。昔のアドレス表現から類推すると、`x@y`は`y!x`と書いてもいい気がする。

  ```text
  genice3 A15 --cation 0=N :group 1=methyl 6=methyl \
      --anion 2=Cl \
      --rep 2 2 2 \
      --seed 99 \
      --exporter svg :shadow :rotate x=5 y=2 x=3 :size O=0.3 H=0.1 HB=0.05 \
      --water 4site!ice
  ```

  あるいは`!`の代わりに`^`を使って

  ```text
  genice3 A15 --cation 0=N :group 1=methyl 6=methyl \
      --anion 2=Cl \
      --rep 2 2 2 \
      --seed 99 \
      --exporter svg :shadow :rotate x=5 y=2 x=3 :size O=0.3 H=0.1 HB=0.05 \
      --water 4site^ice
  ```

  `^`も修飾している感じが出てよいかも。

  `--water`は本来はbaseオプションではなく、exporterのサブオプションなので、その規則に忠実に書くなら

  ```text
  genice3 A15 --cation 0=N :group 1=methyl 6=methyl \
      --anion 2=Cl \
      --rep 2 2 2 \
      --seed 99 \
      --exporter svg :shadow :rotate x=5 y=2 x=3 :size O=0.3 H=0.1 HB=0.05 :water 4site^ice
  ```

  が正しい。(すべてのgenice3プロセスが必ずしも水分子の情報を必要とするわけではない。)ただ、ユーザーはそこまでstrictに考えないだろうから、baseオプションで与えてもいいことにする。これは`unitcell`のサブオプションである`--cation`などと同じ。逆に、現在の表記で厳格にcationをunitcellのサブオプションであるという立場で書くと、cationのサブオプションを書けなくなってしまう。つまり、階層的な表記はけっきょくわかりやすくも便利でもないということがわかってきた。`water`もベースオプション扱いにするのが良いだろう。

  ```shell
  genice3 A15 :cation 0=N :group (??) # groupは cationのオプションだが、表現できない
  ```

---

**結論**: 結局 GenIce2 のフラットな表現からあまり離れられない。階層を明示したいのは開発者のエゴで、利用者にはちっともわかりやすくない、というところが見えてきた。CLI では「よく使うものはベースに並べる」程度のゆるい階層で十分。厳密な階層は YAML や内部構造に閉じておき、ユーザーには見せない。

**オプションの利用追跡と未使用報告**: ベースにオプションを並べる場合、実際にそれを消費するモジュール（exporter など）が呼ばれるまで、そのオプションが必要かどうかは決まらない。ユーザーから見ても、指定したオプションが本当に使われたかどうかが分からない。そこで、どのオプションがどのモジュールに渡され利用されたかを追跡し、終了時に未使用オプションを報告する仕組みがあるとよい（例: `--warn-unused-options` や常時 stderr に一行出すなど）。 typo や取り違えの検出にもつながる。

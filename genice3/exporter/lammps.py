import sys
from logging import getLogger
from io import TextIOWrapper
from typing import Dict, List, Any, Tuple
from collections import defaultdict

import numpy as np

from cif2ice import cellshape, cellvectors
from genice3.molecule import Molecule
from genice3.genice import GenIce3
from genice3.exporter import (
    parse_guest_option,
    parse_spot_guest_option,
    parse_water_model_option,
)
from genice3.cli.pool_parser import (
    OptionDef,
    parse_options_generic,
    OPTION_TYPE_STRING,
    OPTION_TYPE_KEYVALUE,
)

format_desc = {
    "aliases": ["lammps", "lmp"],
    "application": "[LAMMPS](https://www.lammps.org/)",
    "extension": ".lammps",
    "water": "Atomic positions",
    "solute": "Atomic positions",
    "hb": "none",
    "remarks": "Yet to be verified.",
}


def _to_lammps_data(
    cellmat: np.ndarray,
    waters: Dict[int, Molecule],
    guests: List[Molecule],
    ions: Dict[int, Molecule],
    command_line: str = None,
) -> str:
    """Output in LAMMPS data format.

    parametersには、hooksで指定したstageの結果が含まれる。
    """
    logger = getLogger("_to_lammps_data")
    logger.info("Generating LAMMPS data file... (Yet to be verified)")

    # セル行列をLAMMPS形式に変換
    # LAMMPSは直交座標系を前提とするため、必要に応じて変換
    if cellmat[0, 1] != 0 or cellmat[0, 2] != 0 or cellmat[1, 2] != 0:
        logger.info(
            "  The specified reshaping matrix does not obey the requirements for LAMMPS' unit cell convention."
        )
        a, b, c, A, B, C = cellshape(cellmat)
        rotmat = np.linalg.inv(cellmat) @ cellvectors(a, b, c, A, B, C)
        logger.info("  The reshape matrix is reoriented.")
    else:
        rotmat = np.eye(3)

    # 分子種ごとにソートする必要がある。
    molecules = defaultdict(list)
    for water in waters.values():
        molecules[water.name].append(water)
    for guest in guests:
        molecules[guest.name].append(guest)
    for ion in ions.values():
        molecules[ion.name].append(ion)

    # 原子タイプのマッピングを作成
    atom_types = {}
    type_counter = 1
    for mol_name in sorted(molecules.keys()):
        mols = molecules[mol_name]
        if len(mols) > 0:
            # 各分子の原子ラベルを取得してタイプを割り当て
            sample_mol = mols[0]
            for label in sample_mol.labels:
                type_key = f"{mol_name}_{label}"
                if type_key not in atom_types:
                    atom_types[type_key] = type_counter
                    type_counter += 1

    # 原子リストを作成
    atoms = []
    molecule_id = 1
    for mol_name in sorted(molecules.keys()):
        mols = molecules[mol_name]
        for mol in mols:
            for name, position in zip(mol.labels, mol.sites):
                type_key = f"{mol_name}_{name}"
                atom_type = atom_types[type_key]
                atoms.append([molecule_id, atom_type, name, position])
            molecule_id += 1

    # セル行列を回転
    cellmat = cellmat @ rotmat

    # LAMMPSデータファイル形式で出力
    s = ""
    if command_line:
        s += f"# {command_line}\n"
    s += "# Generated by GenIce https://github.com/vitroid/GenIce\n"
    s += f"\n{len(atoms)} atoms\n"
    s += f"{len(atom_types)} atom types\n"

    # ボックスサイズを計算
    # LAMMPSは直交座標系を前提とする
    # セルの原点を(0,0,0)として、各軸の範囲を計算
    xlo, xhi = 0.0, cellmat[0, 0]
    ylo, yhi = 0.0, cellmat[1, 1]
    zlo, zhi = 0.0, cellmat[2, 2]
    s += f"\n0.0 {cellmat[0, 0]:.8f} xlo xhi\n"
    s += f"0.0 {cellmat[1, 1]:.8f} ylo yhi\n"
    s += f"0.0 {cellmat[2, 2]:.8f} zlo zhi\n"
    if not (
        abs(cellmat[1, 0]) < 1e-8
        and abs(cellmat[2, 0]) < 1e-8
        and abs(cellmat[2, 1]) < 1e-8
    ):
        # 非直交セル（tilt形式）
        xy = cellmat[1, 0]
        xz = cellmat[2, 0]
        yz = cellmat[2, 1]
        s += f"{xy:.8f} {xz:.8f} {yz:.8f} xy xz yz\n"

    s += "\nAtoms\n\n"

    # 原子座標をnmからAngstromに変換（LAMMPSは通常Angstromを使用）
    # ただし、unitsコマンドで指定できるので、nmのままでも可
    # ここではnmのまま出力（units realまたはunits metalの場合）
    # 電荷は0.0をデフォルトとする（必要に応じて拡張可能）
    charge = 0.0
    for i, atom in enumerate(atoms):
        mol_id, atom_type, atomname, position = atom
        position = position @ rotmat
        s += f"{i + 1:8d} {mol_id:8d} {atom_type:4d} {charge:10.6f} {position[0]:15.8f} {position[1]:15.8f} {position[2]:15.8f}\n"

    logger.info(f"  Total number of atoms: {len(atoms)}")
    logger.info(f"  Total number of atom types: {len(atom_types)}")
    logger.info(f"  Total number of molecules: {molecule_id - 1}")

    return s


# lammps プラグインが受け取るオプション定義。追加・削除はここだけ行えばよい。
LAMMPS_OPTION_DEFS = (
    OptionDef("guest", parse_type=OPTION_TYPE_KEYVALUE),
    OptionDef("spot_guest", parse_type=OPTION_TYPE_KEYVALUE),
    OptionDef("water_model", parse_type=OPTION_TYPE_STRING),
)


def parse_options(options: Dict[str, Any]) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    """
    lammps プラグインのオプションを型変換して処理する。

    対象は LAMMPS_OPTION_DEFS で定義。water は water_model のエイリアスとして正規化する。

    Args:
        options: プラグインに渡されたオプション辞書。

    Returns:
        (処理したオプション, 処理しなかったオプション)。未処理は次のプラグインへ。
    """
    options = dict(options)
    if "water" in options and "water_model" not in options:
        options["water_model"] = options["water"]

    option_specs = {
        d.name: d.parse_type
        for d in LAMMPS_OPTION_DEFS
        if d.parse_type is not None
    }
    return parse_options_generic(options, option_specs)


def dumps(
    genice: GenIce3,
    guest: dict = {},
    spot_guest: dict = {},
    water_model: str = "3site",
    command_line: str = "",
    name: str = "",  # dummy
):
    """
    LAMMPS形式で出力

    Args:
        genice: GenIce3インスタンス
        guest: ゲスト分子の指定
        spot_guest: 特定のケージに配置するゲスト分子
        water_model: 水分子モデル名
        command_line: コマンドライン文字列
        name: プラグイン名（"lammps"または""）
    """
    logger = getLogger("lammps.dump")
    if name not in ("lammps", ""):
        raise ValueError(f"name must be 'lammps' or '', got: {name}")
    guest_info = parse_guest_option(guest)
    spot_guest_info = parse_spot_guest_option(spot_guest)
    water_model = parse_water_model_option(water_model)
    waters = genice.water_molecules(water_model=water_model)
    guests = genice.guest_molecules(guests=guest_info, spot_guests=spot_guest_info)
    ions = genice.substitutional_ions()

    return _to_lammps_data(
        cellmat=genice.cell,
        waters=waters,
        guests=guests,
        ions=ions,
        command_line=command_line,
    )


def dump(genice: GenIce3, file: TextIOWrapper = sys.stdout, **options):
    file.write(dumps(genice, **options))
